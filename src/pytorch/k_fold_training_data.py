import logging
from random import shuffle as randshuffle
import torch
import numpy as np
import random
from sklearn.model_selection import train_test_split
from torch.utils.data import DataLoader
from src.pytorch.utils.default_args import (
    DEFAULT_BATCH_SIZE,
    DEFAULT_NORMALIZE_OUTPUT,
    DEFAULT_NUM_FOLDS,
    DEFAULT_OUTPUT_LAYER,
    DEFAULT_SHUFFLE,
    DEFAULT_RANDOM_SEED,
    DEFAULT_SHUFFLE_SEED,
    DEFAULT_NORMALIZE_OUTPUT,
    DEFAULT_MODEL,
)

from src.pytorch.training_data import (
    InstanceDataset,
    load_training_state_value_pairs,
)

_log = logging.getLogger(__name__)


class KFoldTrainingData:
    def __init__(
        self,
        samples_file,
        batch_size=DEFAULT_BATCH_SIZE,
        num_folds=DEFAULT_NUM_FOLDS,
        output_layer=DEFAULT_OUTPUT_LAYER,
        shuffle=DEFAULT_SHUFFLE,
        seed=DEFAULT_RANDOM_SEED,
        shuffle_seed=DEFAULT_SHUFFLE_SEED,
        normalize=DEFAULT_NORMALIZE_OUTPUT,
        model=DEFAULT_MODEL,
    ):
        # Getting training data from sas_plan generated by the sampling engine.
        self.state_value_pairs, self.domain_max_value = load_training_state_value_pairs(
            samples_file
        )
        self.normalize = normalize
        if self.normalize:
            for i in range(len(self.state_value_pairs)):
                self.state_value_pairs[i][1] /= self.domain_max_value
        self.batch_size = batch_size
        self.num_folds = num_folds
        self.output_layer = output_layer
        self.shuffle = shuffle
        self.seed = seed
        self.shuffle_seed = seed if shuffle_seed == DEFAULT_SHUFFLE_SEED else shuffle_seed
        self.model = model
        self.kfolds = self.generate_kfold_training_data()

    def generate_kfold_training_data(self):
        """
        Generate the folds.
        Return two list of tuples of size num_folds: dataloaders and problems.
        The first item corresponds to train set, and the second to test set.
        """

        _log.info(f"Generating {self.num_folds}-fold...")

        kfolds = []
        instances_per_fold = int(len(self.state_value_pairs) / self.num_folds)
        for i in range(self.num_folds):
            training_set, test_set = [], []
            if self.num_folds == 1:
                training_set, test_set = train_test_split(
                    self.state_value_pairs,
                    test_size=0.2,
                    shuffle=self.shuffle,
                    random_state=self.shuffle_seed,
                )

            else:
                for j in range(len(self.state_value_pairs)):
                    if int(j / instances_per_fold) == i:
                        test_set.append(self.state_value_pairs[j])
                    else:
                        training_set.append(self.state_value_pairs[j])

            worker_fn = None if self.seed == -1 else lambda id: np.random.seed(self.shuffle_seed % 2 ** 32)
            g = None if self.seed == -1 else torch.Generator()
            if g != None:
                g.manual_seed(self.shuffle_seed)

            train_dataloader = DataLoader(
                dataset=InstanceDataset(
                    training_set, self.domain_max_value, self.output_layer
                ),
                batch_size=self.batch_size,
                shuffle=self.shuffle,
                num_workers=1,
                worker_init_fn=worker_fn,
                generator=g,
            )
            test_dataloader = DataLoader(
                dataset=InstanceDataset(
                    test_set, self.domain_max_value, self.output_layer
                ),
                batch_size=self.batch_size,
                shuffle=self.shuffle,
                num_workers=1,
                worker_init_fn=worker_fn,
                generator=g,
            )

            kfolds.append((train_dataloader, test_dataloader))

        return kfolds

    def get_fold(self, idx):
        """
        Returns a fold as tuple(train dataloader, test dataloader).
        Counting from 0.
        """
        return self.kfolds[idx]

def seed_worker(worker_id):
    """
    Sets the seed of each worker.
    See: https://pytorch.org/docs/stable/notes/randomness.html
    """
    worker_seed = torch.initial_seed() % 2 ** 32
    np.random.seed(worker_seed)
    random.seed(worker_seed)
